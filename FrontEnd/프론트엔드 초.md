1. 브라우저 렌더링 과정
(1) HTML/CSS 파싱

HTML은 파싱되어 DOM 트리 생성

CSS는 파싱되어 CSSOM 트리 생성

<script> 실행 시 HTML 파싱이 잠시 중단됨

(2) Render Tree 생성

DOM + CSSOM 결합

화면에 표시되는 요소만 포함하여 Render Tree 생성

(3) Layout(Reflow)

각 요소의 위치와 크기 계산

(4) Paint

요소를 픽셀로 렌더링

(5) Composite

레이어 단위 합성 → 최종적으로 화면 표시

2. URL 입력 → 페이지 표시 과정 
(1) URL 입력

브라우저가 URL 분석
→ 프로토콜(HTTP/HTTPS), 도메인, 포트, 경로 파싱

(2) DNS 조회

순서:

브라우저 캐시

OS 캐시

라우터

ISP DNS 서버

최종 네임서버

IP 주소 획득

(3) TCP 3-way handshake

클라이언트와 서버 간 연결 성립

(4) 서버로 HTTP 요청 전송

요청 헤더

요청 메서드

Payload(body)

(5) 서버(웹 서버 & WAS) 동작

웹 서버(Nginx, Apache 등): 요청 라우팅
↓
WAS(Spring Boot, Node 등):

비즈니스 로직 실행

DB 조회

결과 JSON 또는 HTML 생성

(6) 응답 반환

브라우저가 응답 획득

(7) 렌더링 진행

HTML → 렌더링 엔진이 화면 표시

3. DNS란?

도메인 이름을 숫자 IP 주소로 변환하는 시스템

예: google.com → 142.251.xxx.xx

4. URI vs URL
구분	의미
URI	자원의 식별 (더 큰 개념)
URL	자원의 위치를 나타냄 (URI의 하위 개념)

예시:

URI: /users/123

URL: https://example.com/users/123

5. RESTful API 규칙 

슬래시(/)로 계층 표현

마지막에 / 붙이지 않기

URI는 명사(자원) 중심

하이픈(-)은 사용 가능, 언더바(_)는 사용 지양

파일 확장자 사용 X

HTTP 메서드로 행동을 표현

GET, POST, PUT, DELETE, PATCH

응답은 JSON 사용

6. HTTP Method 정리 (GET/POST/PUT/PATCH)

GET: 조회

POST: 생성

PUT: 전체 업데이트

PATCH: 부분 업데이트

DELETE: 삭제

7. Payload vs Header

Header: 요청·응답의 메타데이터

Authorization

Content-Type

Cookie

Payload(body): 실제 데이터(JSON 등)

8. CORS 
(1) CORS란?

브라우저의 **Same-Origin Policy(SOP)**로 인해
다른 출처의 리소스 요청을 기본적으로 막는 보안 정책

(2) 해결 방법

너가 적은 3가지 해결 방법 포함:

서버에서 CORS 헤더 설정

Access-Control-Allow-Origin: * 등

프록시 서버 사용

개발 환경에서 Proxy 설정

브라우저 확장 프로그램(개발 환경 한정)

9. JWT vs Session 
Session 방식

서버가 Session 저장

클라이언트는 Cookie로 Session ID만 보냄

서버 메모리·Redis 필요

JWT 방식

토큰 안에 자체적으로 정보 포함

서버는 토큰 검증만 하면 됨 → Stateless

단점: 탈취 시 위험, 강제 만료 처리 어려움

10. OAuth 전체 흐름

Request Token 요청

서비스 제공자 → Request Token 발급

사용자가 로그인/권한 승인

Access Token 발급

Access Token 요청마다 포함하여 API 접근

11. HTTP vs HTTPS
HTTP	평문 통신(암호화 X)
HTTPS	SSL/TLS로 암호화

도청/변조 방지

인증서 필요

12. localStorage / sessionStorage / cookie 
저장소	지속성	크기	특징
localStorage	브라우저 종료 후에도 유지	약 5MB	영구 저장
sessionStorage	탭 닫으면 삭제	약 5MB	탭별로 독립
cookie	만료 기반	4KB	HTTP 요청마다 자동 전송(주의)
13. Semantic Markup

HTML 요소를 의미에 맞게 사용하는 것

<header>

<main>

<nav>

<article>

검색엔진 최적화(SEO)에 유리

스크린 리더 접근성 향상

14. attributes vs properties

attributes: HTML 문서에 지정된 값

properties: DOM 객체의 동적 프로퍼티
→ 서로 연동되지만 항상 같지는 않음

15. SPA / CSR / SSR
SPA

최초 로드 후 화면 전환은 JS로 처리

장점: 빠른 전환

단점: SEO 약함, JS 의존 큼

CSR

브라우저에서 JS로 렌더링

최초 로딩 느림

SSR

서버에서 HTML 생성 후 전달

SEO 좋음, 초기 렌더링 빠름

16. Webpack / Babel / Polyfill
Webpack

모듈 번들러

여러 JS/CSS를 하나의 번들 파일로 합침

Babel

최신 JS → 브라우저 호환 가능한 코드로 변환

Polyfill

브라우저가 지원하지 않는 기능을 미리 구현하여 제공

17. 페이지 로딩 속도 개선
이미지 최적화

Lazy loading

코드 스플리팅

캐싱 활용

CDN 사용

불필요한 JS 제거

압축(minify)

18. 테스트 종류 

Unit Test: 함수/모듈 단위

Integration Test: 여러 모듈 연동 검증

E2E Test: UI → API까지 실제 사용자 플로우 테스트

19. MVC / MVVM
MVC

Model: 데이터

View: UI

Controller: 요청 처리·로직

MVVM

Model: 데이터

View: UI

ViewModel: 상태·로직 관리

양방향 바인딩 용이

20. 배포 환경

S3 정적 호스팅

CloudFront CDN

CI/CD로 자동 배포 가능

GitHub Actions 사용 가능

무중단 배포는 Blue-Green 방식 가능

21. CI/CD 전체 개념 

코드 push 시 자동 빌드/테스트

품질 보증

CD

자동 배포

수동 또는 자동 릴리즈
